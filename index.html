<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>사이버펑크 탑다운 슈터 v2.1</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* CSS는 이전과 동일 */
        body { margin: 0; overflow: hidden; background-color: #000; display: flex; justify-content: center; align-items: center; min-height: 100vh; font-family: 'Press Start 2P', cursive; color: #fff; text-align: center; }
        #game-container { position: relative; width: 800px; height: 600px; border-radius: 10px; overflow: hidden; box-shadow: 0 0 15px 5px rgba(0, 255, 255, 0.6), 0 0 5px 1px rgba(255, 0, 255, 0.5) inset; cursor: crosshair; border: 1px solid rgba(0, 255, 255, 0.3); }
        canvas { display: block; width: 100%; height: 100%; background-color: #050510; }
        #ui-container { position: absolute; top: 15px; left: 15px; right: 15px; display: flex; justify-content: space-between; align-items: flex-start; pointer-events: none; font-size: 18px; }
        #score-info { text-align: left; text-shadow: 0 0 5px #0f0; }
        #upgrade-info { text-align: right; text-shadow: 0 0 5px #ff0; }
        #score { color: #0f0; font-size: 22px; margin-bottom: 5px; }
        #high-score { color: #f90; font-size: 16px; margin-bottom: 5px; text-shadow: 0 0 5px #f90; }
        #upgrade-points, #next-upgrade-progress { color: #ff0; margin-bottom: 5px; font-size: 16px; }
        #dash-status { position: absolute; bottom: 15px; left: 15px; font-size: 14px; color: #0ff; text-shadow: 0 0 5px #0ff; }
        #upgrade-message { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); font-size: 18px; color: #f0f; text-shadow: 0 0 7px #f0f; opacity: 0; transition: opacity 0.5s ease-out; pointer-events: none; }
        #upgrade-choice-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); display: none; justify-content: center; align-items: center; z-index: 10; pointer-events: auto; }
        #upgrade-choice-container { background-color: rgba(10, 10, 20, 0.95); padding: 30px 40px; border-radius: 10px; border: 2px solid #f0f; box-shadow: 0 0 25px #f0f; text-align: center; }
        #upgrade-choice-container h3 { margin: 0 0 10px 0; font-size: 24px; color: #f0f; text-shadow: 0 0 5px #f0f; }
        #upgrade-choice-container p { font-size: 12px; color: #aaa; margin-bottom: 25px; }
        .upgrade-button-container { display: flex; justify-content: center; gap: 10px; flex-wrap: wrap; }
        .upgrade-option { display: flex; flex-direction: column; align-items: center; margin-bottom: 10px; }
        .upgrade-button { font-family: 'Press Start 2P', cursive; font-size: 13px; padding: 8px 12px; margin: 0; border: 1px solid rgba(255, 255, 255, 0.5); border-radius: 8px; cursor: pointer; transition: transform 0.1s ease, box-shadow 0.1s ease, filter 0.1s ease, background-color 0.1s ease; color: #fff; text-shadow: 0 0 3px #000; min-width: 110px; background-color: rgba(50, 50, 50, 0.7); }
        .upgrade-button-label { font-size: 10px; color: #ccc; margin-top: 5px; }
        #upgrade-firerate { border-color: #ff4500; } #upgrade-firerate:hover { background-color: #ff4500; box-shadow: 0 0 15px #ff4500; }
        #upgrade-damage { border-color: #ff416c; } #upgrade-damage:hover { background-color: #ff416c; box-shadow: 0 0 15px #ff416c; }
        #upgrade-spread { border-color: #8a2be2; } #upgrade-spread:hover { background-color: #8a2be2; box-shadow: 0 0 15px #8a2be2; }
        #upgrade-dash { border-color: #2193b0; } #upgrade-dash:hover { background-color: #2193b0; box-shadow: 0 0 15px #2193b0; }
        .upgrade-button:active { transform: scale(0.95); filter: brightness(0.8); }
        #message-box { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(10, 0, 10, 0.9); padding: 45px; border-radius: 15px; display: none; flex-direction: column; align-items: center; pointer-events: auto; border: 3px solid #f0f; box-shadow: 0 0 25px #f0f; z-index: 10; }
        #message-box h2 { margin: 0 0 20px 0; color: #f00; text-shadow: 0 0 7px #f00; font-size: 36px; }
        #message-box p { margin: 0 0 30px 0; font-size: 20px; color: #eee; }
        #new-highscore-message { color: #ff0; font-size: 22px; margin-bottom: 15px; display: none; text-shadow: 0 0 5px #ff0; }
        #restart-button { font-family: 'Press Start 2P', cursive; font-size: 22px; padding: 15px 30px; background: linear-gradient(45deg, #f0f, #0ff); color: #fff; border: none; border-radius: 12px; cursor: pointer; transition: transform 0.1s ease, box-shadow 0.1s ease; box-shadow: 0 6px 12px rgba(255, 0, 255, 0.5); text-shadow: 0 0 5px #000; }
        #restart-button:hover { transform: scale(1.05); box-shadow: 0 8px 16px rgba(255, 0, 255, 0.7); }
        #restart-button:active { transform: scale(0.95); }
        
        /* 난이도 선택 오버레이 스타일 */
        #difficulty-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 20;
            pointer-events: auto;
        }
        
        #difficulty-container {
            background-color: rgba(10, 10, 20, 0.95);
            padding: 30px 40px;
            border-radius: 10px;
            border: 2px solid #f0f;
            box-shadow: 0 0 25px #f0f;
            text-align: center;
        }
        
        #difficulty-container h3 {
            margin: 0 0 20px 0;
            font-size: 24px;
            color: #f0f;
            text-shadow: 0 0 5px #f0f;
        }
        
        #difficulty-container p {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 25px;
        }
        
        .difficulty-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .difficulty-button {
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            padding: 12px 20px;
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.1s ease, box-shadow 0.1s ease;
            color: #fff;
            text-shadow: 0 0 3px #000;
            min-width: 120px;
        }
        
        #easy-button {
            border-color: #00ff00;
            background-color: rgba(0, 100, 0, 0.7);
        }
        
        #easy-button:hover {
            background-color: #00ff00;
            box-shadow: 0 0 15px #00ff00;
        }
        
        #normal-button {
            border-color: #ffff00;
            background-color: rgba(100, 100, 0, 0.7);
        }
        
        #normal-button:hover {
            background-color: #ffff00;
            box-shadow: 0 0 15px #ffff00;
        }
        
        #hard-button {
            border-color: #ff0000;
            background-color: rgba(100, 0, 0, 0.7);
        }
        
        #hard-button:hover {
            background-color: #ff0000;
            box-shadow: 0 0 15px #ff0000;
        }
        
        .difficulty-button:active {
            transform: scale(0.95);
        }
        
        #difficulty-value {
            position: absolute;
            top: 15px;
            right: 15px;
            color: #0ff;
            font-size: 14px;
            text-shadow: 0 0 5px #0ff;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="ui-container">
            <div id="score-info">
                <div id="score">Score: 0</div>
                <div id="high-score">High: 0</div>
            </div>
            <div id="upgrade-info">
                 <div id="upgrade-points">Points: 0</div>
                 <div id="next-upgrade-progress">Next: 200pts</div>
            </div>
        </div>
         <div id="dash-status">Dash: READY</div>
         <div id="upgrade-message"></div>
         <div id="upgrade-choice-overlay">
             <div id="upgrade-choice-container">
                 <h3>Choose Upgrade (1 Point)</h3>
                 <p>Enhance your cybernetics.</p>
                 <div class="upgrade-button-container">
                     <div class="upgrade-option">
                         <button id="upgrade-firerate" class="upgrade-button">Fire Rate+</button>
                         <span id="firerate-label" class="upgrade-button-label">Cooldown: 20</span>
                     </div>
                     <div class="upgrade-option">
                         <button id="upgrade-damage" class="upgrade-button">Damage+</button>
                         <span id="damage-label" class="upgrade-button-label">Damage: 1.0</span>
                     </div>
                      <div class="upgrade-option">
                         <button id="upgrade-spread" class="upgrade-button">Spread+</button>
                         <span id="spread-label" class="upgrade-button-label">Bullets: 1</span>
                     </div>
                      <div class="upgrade-option">
                         <button id="upgrade-dash" class="upgrade-button">Dash CD-</button>
                         <span id="dash-label" class="upgrade-button-label">Cooldown: 2.0s</span>
                     </div>
                 </div>
             </div>
         </div>
        <div id="message-box">
            <h2>SYSTEM OFFLINE</h2>
            <p id="new-highscore-message">New High Score Archived!</p>
            <p id="final-score">Job Score: 0</p>
            <button id="restart-button">Reboot System</button>
        </div>
        
        <!-- 난이도 선택 오버레이 -->
        <div id="difficulty-overlay">
            <div id="difficulty-container">
                <h3>난이도 선택</h3>
                <p>적의 스폰 확률, 속도, 체력이 변경됩니다.<br>대시 시 짧은 시간 동안 무적 상태가 됩니다!</p>
                <div class="difficulty-buttons">
                    <button id="easy-button" class="difficulty-button">쉬움</button>
                    <button id="normal-button" class="difficulty-button">보통</button>
                    <button id="hard-button" class="difficulty-button">어려움</button>
                </div>
            </div>
        </div>
        
        <!-- 현재 난이도 표시 -->
        <div id="difficulty-value">난이도: 쉬움</div>
    </div>

    <script>
        // --- 요소 가져오기 (이전과 동일) ---
        const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container'); const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('high-score'); const upgradePointsElement = document.getElementById('upgrade-points');
        const nextUpgradeProgressElement = document.getElementById('next-upgrade-progress'); const dashStatusElement = document.getElementById('dash-status');
        const upgradeMessageElement = document.getElementById('upgrade-message'); const upgradeChoiceOverlay = document.getElementById('upgrade-choice-overlay');
        const upgradeFirerateButton = document.getElementById('upgrade-firerate'); const upgradeDamageButton = document.getElementById('upgrade-damage');
        const upgradeSpreadButton = document.getElementById('upgrade-spread'); const upgradeDashButton = document.getElementById('upgrade-dash');
        const firerateLabel = document.getElementById('firerate-label'); const damageLabel = document.getElementById('damage-label');
        const spreadLabel = document.getElementById('spread-label'); const dashLabel = document.getElementById('dash-label');
        const messageBox = document.getElementById('message-box'); const finalScoreElement = document.getElementById('final-score');
        const newHighScoreMessageElement = document.getElementById('new-highscore-message'); const restartButton = document.getElementById('restart-button');
        
        // 난이도 선택 요소 가져오기
        const difficultyOverlay = document.getElementById('difficulty-overlay');
        const easyButton = document.getElementById('easy-button');
        const normalButton = document.getElementById('normal-button');
        const hardButton = document.getElementById('hard-button');
        const difficultyValueElement = document.getElementById('difficulty-value');

        // --- 게임 변수 (이전과 동일) ---
        let player; let bullets = []; let enemies = []; let enemyBullets = []; let particles = []; let pickups = []; let gridLines = [];
        let score = 0; let highScore = 0; let gameOver = false; let isPaused = false; let gameLoopId; let keys = {};
        let mousePos = { x: 0, y: 0 }; let enemySpawnTimer = 0; let baseEnemySpawnInterval = 120; let currentEnemySpawnInterval = baseEnemySpawnInterval;
        let minEnemySpawnInterval = 40; let difficultyIncreaseFactor = 0.03; let difficultyMultiplier = 1.0;
        let upgradeMessageTimeout; let screenShakeIntensity = 0; let screenShakeDuration = 0;
        const scoreThresholds = [200, 500, 1000, 2000, 4000, 7000, 10000]; let currentUpgradeLevel = 0;
        const SHOOTER_ENEMY_SCORE_THRESHOLD = 1500;
        
        // 난이도 관련 변수 추가
        let currentDifficulty = 'easy'; // 기본값은 쉬움
        let difficultyMultipliers = {
            easy: {
                enemyHealth: 1.0,
                enemySpeed: 1.0,
                enemySpawn: 1.0,
                enemyDamage: 1.0,
                scoreMultiplier: 1.0
            },
            normal: {
                enemyHealth: 1.3,
                enemySpeed: 1.2,
                enemySpawn: 1.2,
                enemyDamage: 1.2,
                scoreMultiplier: 1.3
            },
            hard: {
                enemyHealth: 1.4,
                enemySpeed: 1.3,
                enemySpawn: 1.4,
                enemyDamage: 1.3,
                scoreMultiplier: 1.7
            }
        };

        // --- 색상 정의 (이전과 동일) ---
        const playerColor = '#00ffff'; const playerGlow = 'rgba(0, 255, 255, 0.7)';
        const bulletColor = '#f0ffff'; const bulletGlow = 'rgba(0, 255, 255, 0.8)';
        const enemyNormalColor = '#4444ff'; const enemyNormalGlow = 'rgba(100, 100, 255, 0.6)';
        const enemyFastColor = '#ff4500'; const enemyFastGlow = 'rgba(255, 69, 0, 0.6)';
        const enemyShooterColor = '#ff00ff'; const enemyShooterGlow = 'rgba(255, 0, 255, 0.6)';
        const enemyBulletColor = '#ff1493'; const pickupColor = '#00ff00'; const pickupGlow = 'rgba(0, 255, 0, 0.7)';
        const gridColor = 'rgba(0, 150, 255, 0.2)';

        // --- 클래스 정의 ---
        class Particle { /* 이전과 동일 */ constructor(x,y,r,c,v){this.x=x;this.y=y;this.radius=r;this.color=c;this.velocity=v;this.alpha=1;this.friction=0.98;} draw(){ctx.save();ctx.globalAlpha=this.alpha;ctx.beginPath();ctx.arc(this.x,this.y,this.radius,0,Math.PI*2,false);ctx.fillStyle=this.color;ctx.shadowColor=this.color;ctx.shadowBlur=5;ctx.fill();ctx.restore();} update(){this.velocity.x*=this.friction;this.velocity.y*=this.friction;this.x+=this.velocity.x;this.y+=this.velocity.y;this.alpha-=0.03;} }
        class HealthPickup { /* 이전과 동일 */ constructor(x,y){this.x=x;this.y=y;this.size=12;this.color=pickupColor;this.glow=pickupGlow;this.healAmount=20;this.life=360;} draw(){ctx.save();ctx.fillStyle=this.color;ctx.shadowColor=this.glow;ctx.shadowBlur=10;ctx.fillRect(this.x-this.size/2,this.y-this.size/2,this.size,this.size);ctx.fillStyle='white';ctx.fillRect(this.x-this.size*0.1,this.y-this.size*0.3,this.size*0.2,this.size*0.6);ctx.fillRect(this.x-this.size*0.3,this.y-this.size*0.1,this.size*0.6,this.size*0.2);ctx.restore();} update(){this.life--;} }
        class Player { /* 이전과 동일 */ constructor(x,y,s,c,sp){this.x=x;this.y=y;this.size=s;this.color=playerColor;this.glow=playerGlow;this.baseSpeed=sp;this.maxHealth=100;this.health=this.maxHealth;this.angle=0;this.fireRateLevel=0;this.baseFireCooldown=20;this.fireCooldown=this.baseFireCooldown;this.fireTimer=0;this.upgradePoints=0;this.bulletDamage=1;this.bulletSpreadLevel=0;this.dashCooldownLevel=0;this.baseDashCooldown=120;this.dashCooldown=this.baseDashCooldown;this.minDashCooldown=30;this.dashCooldownReduction=15;this.dashTimer=0;this.dashDuration=10;this.dashDistance=100;this.isDashing=false;this.dashCurrentDuration=0;this.dashStartX=0;this.dashStartY=0;this.dashTargetX=0;this.dashTargetY=0;this.trail=[];
        // 대시 무적 상태 추가
        this.isInvincible=false;
        this.invincibilityDuration=25; // 무적 시간 증가 (프레임 단위)
        this.invincibilityTimer=0; 
    } draw(){this.angle=Math.atan2(mousePos.y-this.y,mousePos.x-this.x);ctx.save();ctx.translate(this.x,this.y);ctx.rotate(this.angle);

    // 무적 상태일 때 깜빡임 효과 추가
    const isVisible = !this.isInvincible || (Math.floor(Date.now() / 50) % 2 === 0);
    ctx.globalAlpha = isVisible ? 1 : 0.3;

    this.trail.forEach((p)=>{ctx.save();ctx.globalAlpha=p.alpha * (isVisible ? 1 : 0.3);ctx.translate(p.x-this.x,p.y-this.y);ctx.rotate(p.angle-this.angle);ctx.beginPath();ctx.moveTo(this.size*0.8,0);ctx.lineTo(-this.size*0.4,-this.size*0.5);ctx.lineTo(-this.size*0.4,this.size*0.5);ctx.closePath();ctx.fillStyle=this.glow;ctx.fill();ctx.restore();});ctx.beginPath();ctx.moveTo(this.size,0);ctx.lineTo(this.size*0.3,-this.size*0.4);ctx.lineTo(-this.size*0.6,-this.size*0.5);ctx.lineTo(-this.size*0.4,0);ctx.lineTo(-this.size*0.6,this.size*0.5);ctx.lineTo(this.size*0.3,this.size*0.4);ctx.closePath();ctx.fillStyle=this.color;ctx.shadowColor=this.glow;ctx.shadowBlur=15;ctx.fill();ctx.strokeStyle='rgba(255,255,255,0.7)';ctx.lineWidth=1;ctx.beginPath();ctx.moveTo(-this.size*0.4,0);ctx.lineTo(this.size*0.8,0);ctx.stroke();ctx.restore();const hBW=40;const hBH=6;const hBX=this.x-hBW/2;const hBY=this.y-this.size*1.5-hBH;ctx.fillStyle='#555';ctx.fillRect(hBX,hBY,hBW,hBH);const cHW=hBW*(this.health/this.maxHealth);ctx.fillStyle=this.health>30?this.color:'#f00';ctx.fillRect(hBX,hBY,Math.max(0,cHW),hBH);} update(){if(this.fireTimer>0)this.fireTimer--;if(this.dashTimer>0)this.dashTimer--;

    // 무적 타이머 업데이트
    if(this.isInvincible) {
        this.invincibilityTimer--;
        if(this.invincibilityTimer <= 0) {
            this.isInvincible = false;
        }
    }

    this.trail=this.trail.filter(p=>p.alpha>0);this.trail.forEach(p=>p.alpha-=0.05);if(this.isDashing){this.dashCurrentDuration++;let t=this.dashCurrentDuration/this.dashDuration;t=t<0?0:t>1?1:t;t=t*(2-t);this.x=lerp(this.dashStartX,this.dashTargetX,t);this.y=lerp(this.dashStartY,this.dashTargetY,t);if(this.dashCurrentDuration%2===0){this.trail.push({x:this.x,y:this.y,angle:this.angle,alpha:0.6});}if(this.dashCurrentDuration>=this.dashDuration){this.isDashing=false;this.x=this.dashTargetX;this.y=this.dashTargetY;}}if(this.dashTimer>0){dashStatusElement.textContent=`Dash: ${(this.dashTimer/60).toFixed(1)}s`;dashStatusElement.style.color='#aaa';}else{dashStatusElement.textContent=`Dash: READY`;dashStatusElement.style.color='#0ff';}} triggerDash(){if(this.dashTimer<=0&&!this.isDashing){this.isDashing=true;this.dashCurrentDuration=0;this.dashTimer=this.dashCooldown;this.dashStartX=this.x;this.dashStartY=this.y;const a=Math.atan2(mousePos.y-this.y,mousePos.x-this.x);let tX=this.x+Math.cos(a)*this.dashDistance;let tY=this.y+Math.sin(a)*this.dashDistance;this.dashTargetX=Math.max(this.size,Math.min(canvas.width-this.size,tX));this.dashTargetY=Math.max(this.size,Math.min(canvas.height-this.size,tY));createExplosion(this.x,this.y,'white',8,3);

    // 대시 시 무적 상태 활성화
    this.isInvincible = true;
    this.invincibilityTimer = this.invincibilityDuration;
}} takeDamage(amount){
// 무적 상태면 데미지 무시
if(this.isInvincible) return;

this.health-=amount;triggerScreenShake(6,12);if(this.health<=0){this.health=0;gameOver=true;createExplosion(this.x,this.y,this.color,30,4);}else{createExplosion(this.x,this.y,'red',5,2);}} heal(amount){this.health=Math.min(this.maxHealth,this.health+amount);createExplosion(this.x,this.y,pickupColor,10,3);} shoot(){if(this.fireTimer<=0){const bS=7;const mX=this.x+Math.cos(this.angle)*this.size;const mY=this.y+Math.sin(this.angle)*this.size;const bTS=this.bulletSpreadLevel+1;const sA=Math.PI/18;for(let i=0;i<bTS;i++){const cA=this.angle-(sA*this.bulletSpreadLevel/2)+(i*sA);const v={x:Math.cos(cA)*bS,y:Math.sin(cA)*bS};bullets.push(new Bullet(mX,mY,4,bulletColor,v));}this.fireTimer=this.fireCooldown;}} upgradeFireRate(){this.fireRateLevel++;this.fireCooldown=Math.max(5,this.baseFireCooldown-this.fireRateLevel*2);showUpgradeMessage("Fire Rate Matrix Optimized!");} upgradeDamage(){this.bulletDamage+=0.5;showUpgradeMessage(`Damage Output Increased! (${this.bulletDamage.toFixed(1)})`);} upgradeSpread(){if(this.bulletSpreadLevel<4){this.bulletSpreadLevel++;showUpgradeMessage(`Projectile Spread Enhanced! (${this.bulletSpreadLevel+1})`);}else{showUpgradeMessage(`Spread Matrix Maxed!`);}} upgradeDashCooldown(){this.dashCooldownLevel++;this.dashCooldown=Math.max(this.minDashCooldown,this.baseDashCooldown-this.dashCooldownLevel*this.dashCooldownReduction);showUpgradeMessage(`Dash Recalibration Complete! (${(this.dashCooldown/60).toFixed(1)}s)`);} addUpgradePoint(){this.upgradePoints++;updateUpgradeUI();} spendUpgradePoint(){if(this.upgradePoints>0){this.upgradePoints--;updateUpgradeUI();return true;}return false;} }
        class Bullet { /* 이전과 동일 */ constructor(x,y,r,c,v){this.x=x;this.y=y;this.radius=r;this.color=c;this.glow=bulletGlow;this.velocity=v;} draw(){ctx.beginPath();ctx.arc(this.x,this.y,this.radius,0,Math.PI*2,false);ctx.fillStyle=this.color;ctx.shadowColor=this.glow;ctx.shadowBlur=8;ctx.fill();ctx.shadowColor='transparent';ctx.shadowBlur=0;ctx.closePath();} update(){this.x+=this.velocity.x;this.y+=this.velocity.y;} }
        class EnemyBullet { /* 이전과 동일 */ constructor(x,y,r,c,v){this.x=x;this.y=y;this.radius=r;this.color=enemyBulletColor;this.velocity=v;} draw(){ctx.beginPath();ctx.arc(this.x,this.y,this.radius,0,Math.PI*2,false);ctx.fillStyle=this.color;ctx.shadowColor='red';ctx.shadowBlur=5;ctx.fill();ctx.shadowColor='transparent';ctx.shadowBlur=0;ctx.closePath();} update(){this.x+=this.velocity.x;this.y+=this.velocity.y;} }
        class Enemy {
            constructor(x,y,s,c,sp,h=1,t='normal'){
                this.x=x;
                this.y=y;
                this.size=s;
                
                if(t==='normal'){
                    this.color=enemyNormalColor;
                    this.glow=enemyNormalGlow;
                } else if(t==='fast'){
                    this.color=enemyFastColor;
                    this.glow=enemyFastGlow;
                } else if(t==='shooter'){
                    this.color=enemyShooterColor;
                    this.glow=enemyShooterGlow;
                } else {
                    this.color=c;
                    this.glow=c;
                }
                
                const dm = difficultyMultipliers[currentDifficulty];
                this.baseSpeed=sp;
                this.baseHealth=h;
                this.type=t;
                this.speed=sp*(1+(difficultyMultiplier-1)*0.8) * dm.enemySpeed;
                this.maxHealth=Math.ceil(h*(1+(difficultyMultiplier-1)*0.6) * dm.enemyHealth);
                this.health=this.maxHealth;
                this.shootCooldown=120 / dm.enemySpeed;  // 난이도 높을수록 발사 속도도 빨라짐
                this.shootTimer=Math.random()*this.shootCooldown;
            }
            
            draw(){
                ctx.save();
                ctx.fillStyle=this.color;
                ctx.shadowColor=this.glow;
                ctx.shadowBlur=10;
                
                if(this.type==='shooter'){
                    ctx.beginPath();
                    ctx.arc(this.x,this.y,this.size*0.6,0,Math.PI*2);
                    ctx.fill();
                    ctx.save();
                    ctx.translate(this.x,this.y);
                    ctx.rotate(Math.atan2(player.y-this.y,player.x-this.x));
                    ctx.fillStyle='grey';
                    ctx.shadowBlur=0;
                    ctx.fillRect(0,-this.size*0.15,this.size*0.8,this.size*0.3);
                    ctx.restore();
                } else if(this.type==='fast'){
                    ctx.beginPath();
                    ctx.moveTo(this.x,this.y+this.size*0.6);
                    ctx.lineTo(this.x-this.size*0.5,this.y-this.size*0.4);
                    ctx.lineTo(this.x,this.y-this.size*0.1);
                    ctx.lineTo(this.x+this.size*0.5,this.y-this.size*0.4);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    const cR=this.size*0.2;
                    ctx.beginPath();
                    ctx.moveTo(this.x-this.size/2+cR,this.y-this.size/2);
                    ctx.lineTo(this.x+this.size/2-cR,this.y-this.size/2);
                    ctx.quadraticCurveTo(this.x+this.size/2,this.y-this.size/2,this.x+this.size/2,this.y-this.size/2+cR);
                    ctx.lineTo(this.x+this.size/2,this.y+this.size/2-cR);
                    ctx.quadraticCurveTo(this.x+this.size/2,this.y+this.size/2,this.x+this.size/2-cR,this.y+this.size/2);
                    ctx.lineTo(this.x-this.size/2+cR,this.y+this.size/2);
                    ctx.quadraticCurveTo(this.x-this.size/2,this.y+this.size/2,this.x-this.size/2,this.y+this.size/2-cR);
                    ctx.lineTo(this.x-this.size/2,this.y-this.size/2+cR);
                    ctx.quadraticCurveTo(this.x-this.size/2,this.y-this.size/2,this.x-this.size/2+cR,this.y-this.size/2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle='rgba(255,255,255,0.3)';
                    ctx.shadowBlur=0;
                    ctx.beginPath();
                    ctx.arc(this.x,this.y,this.size*0.2,0,Math.PI*2);
                    ctx.fill();
                }
                
                ctx.restore();
                
                if(this.maxHealth>1&&this.type==='normal'){
                    const hBW=this.size;
                    const hBH=4;
                    const hBX=this.x-hBW/2;
                    const hBY=this.y-this.size/2-hBH-2;
                    ctx.fillStyle='#555';
                    ctx.fillRect(hBX,hBY,hBW,hBH);
                    const cHW=hBW*(this.health/this.maxHealth);
                    ctx.fillStyle='#f00';
                    ctx.fillRect(hBX,hBY,Math.max(0,cHW),hBH);
                }
            }
            
            update(){
                const dm = difficultyMultipliers[currentDifficulty];
                this.speed=this.baseSpeed*(1+(difficultyMultiplier-1)*0.8) * dm.enemySpeed;
                
                const aTP=Math.atan2(player.y-this.y,player.x-this.x);
                
                if(this.type==='shooter'){
                    const dD=200;
                    const cD=distance(this.x,this.y,player.x,player.y);
                    let mA=aTP;
                    
                    if(cD<dD-20){
                        mA+=Math.PI;
                    } else if(cD<=dD+20){
                        mA+=Math.PI/2*Math.sign(Math.cos(Date.now()/500));
                    }
                    
                    this.x+=Math.cos(mA)*this.speed*0.7;
                    this.y+=Math.sin(mA)*this.speed*0.7;
                    
                    this.shootTimer++;
                    if(this.shootTimer>=this.shootCooldown){
                        this.shootTimer=0;
                        const bS=3*difficultyMultiplier * dm.enemySpeed;
                        const v={x:Math.cos(aTP)*bS,y:Math.sin(aTP)*bS};
                        enemyBullets.push(new EnemyBullet(this.x,this.y,5,'red',v));
                    }
                } else {
                    this.x+=Math.cos(aTP)*this.speed;
                    this.y+=Math.sin(aTP)*this.speed;
                }
                
                this.x=Math.max(this.size/2,Math.min(canvas.width-this.size/2,this.x));
                this.y=Math.max(this.size/2,Math.min(canvas.height-this.size/2,this.y));
            }
            
            takeDamage(damage){
                this.health-=damage;
                createExplosion(this.x,this.y,this.color,3,1.5);
                return this.health<=0;
            }
        }

        // --- 헬퍼 함수 (이전과 동일) ---
        function lerp(s,e,t){return s*(1-t)+e*t;} function distance(x1,y1,x2,y2){const xD=x2-x1;const yD=y2-y1;return Math.sqrt(xD*xD+yD*yD);} function detectCollisionCircleRect(c,r){const cX=Math.max(r.x-r.size/2,Math.min(c.x,r.x+r.size/2));const cY=Math.max(r.y-r.size/2,Math.min(c.y,r.y+r.size/2));const d=distance(c.x,c.y,cX,cY);return d<c.radius;} function detectCollisionPlayerEnemy(p,e){const pC={x:p.x,y:p.y,radius:p.size*0.8};if(e.type==='shooter'){return detectCollisionCircleRect(pC,{x:e.x,y:e.y,size:e.size*1.4});}else{return detectCollisionCircleRect(pC,e);}} function detectCollisionPlayerPickup(p,pk){const d=distance(p.x,p.y,pk.x,pk.y);return d<p.size*0.8+pk.size/2;} function detectCollisionBulletPlayer(b,p){const d=distance(b.x,b.y,p.x,p.y);return d<b.radius+p.size*0.7;} function updateMousePos(e){const r=canvas.getBoundingClientRect();mousePos.x=e.clientX-r.left;mousePos.y=e.clientY-r.top;} function createExplosion(x,y,c,cnt=10,sM=3){for(let i=0;i<cnt;i++){const r=Math.random()*sM+1;const v={x:(Math.random()-0.5)*(Math.random()*7),y:(Math.random()-0.5)*(Math.random()*7)};particles.push(new Particle(x,y,r,c,v));}} 
        
        // 적 생성 함수를 난이도에 맞게 수정
        function spawnEnemy(){
            let s,c,bS,bH,t;
            const eTR=Math.random();
            const cSS=score>=SHOOTER_ENEMY_SCORE_THRESHOLD;
            const dm = difficultyMultipliers[currentDifficulty];
            
            if(cSS&&eTR<0.15){
                t='shooter';
                s=20;
                c=enemyShooterColor;
                bS=0.8 * dm.enemySpeed;
                bH=5 * dm.enemyHealth;
            }else if(eTR<0.35){
                t='fast';
                s=Math.random()*10+10;
                c=enemyFastColor;
                bS=(Math.random()*1.5+1.0) * dm.enemySpeed;
                bH=0.5 * dm.enemyHealth;
            }else{
                t='normal';
                s=Math.random()*20+15;
                c=enemyNormalColor;
                bS=(Math.random()*1+0.5) * dm.enemySpeed;
                bH=(Math.random()<0.1?3:1) * dm.enemyHealth;
            }
            
            let x,y;
            if(Math.random()<0.5){
                x=Math.random()<0.5?0-s:canvas.width+s;
                y=Math.random()*canvas.height;
            }else{
                x=Math.random()*canvas.width;
                y=Math.random()<0.5?0-s:canvas.height+s;
            }
            
            enemies.push(new Enemy(x,y,s,c,bS,bH,t));
        } 
        
        function showUpgradeMessage(m){upgradeMessageElement.textContent=m;clearTimeout(upgradeMessageTimeout);upgradeMessageElement.style.opacity=1;upgradeMessageTimeout=setTimeout(()=>{upgradeMessageElement.style.opacity=0;},2000);} function updateUpgradeUI(){if(!player)return;upgradePointsElement.textContent=`Creds: ${player.upgradePoints}`;if(currentUpgradeLevel<scoreThresholds.length){const nT=scoreThresholds[currentUpgradeLevel];const pN=Math.max(0,nT-score);nextUpgradeProgressElement.textContent=`Next: ${pN}pts`;}else{nextUpgradeProgressElement.textContent="Next: MAX";}firerateLabel.textContent=`Cool: ${player.fireCooldown}`;damageLabel.textContent=`Dmg: ${player.bulletDamage.toFixed(1)}`;spreadLabel.textContent=`Proj: ${player.bulletSpreadLevel+1}`;dashLabel.textContent=`Cool: ${(player.dashCooldown/60).toFixed(1)}s`;} function triggerScreenShake(i,d){screenShakeIntensity=i;screenShakeDuration=d;}
        
        // 난이도 선택 이벤트 핸들러
        function handleDifficultyChoice(difficulty) {
            currentDifficulty = difficulty;
            difficultyOverlay.style.display = 'none';
            
            // 난이도에 따른 UI 업데이트
            if(difficulty === 'easy') {
                difficultyValueElement.textContent = "난이도: 쉬움";
                difficultyValueElement.style.color = "#00ff00";
            } else if(difficulty === 'normal') {
                difficultyValueElement.textContent = "난이도: 보통";
                difficultyValueElement.style.color = "#ffff00";
            } else {
                difficultyValueElement.textContent = "난이도: 어려움";
                difficultyValueElement.style.color = "#ff0000";
            }
            
            // 게임 시작
            startGame();
            
            // 난이도 메시지 표시
            showUpgradeMessage(`${difficulty === 'easy' ? '쉬움' : difficulty === 'normal' ? '보통' : '어려움'} 난이도로 시작!`);
        }
        
        const gridSpacing = 50; const gridScrollSpeed = 0.3; let gridOffsetY = 0;
        function drawBackground(){ctx.fillStyle='#050510';ctx.fillRect(0,0,canvas.width,canvas.height);gridOffsetY=(gridOffsetY+gridScrollSpeed)%gridSpacing;ctx.strokeStyle=gridColor;ctx.lineWidth=1;ctx.shadowColor='rgba(0,200,255,0.5)';ctx.shadowBlur=5;for(let y=gridOffsetY;y<canvas.height;y+=gridSpacing){const pF=y/canvas.height;ctx.globalAlpha=0.1+pF*0.4;ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(canvas.width,y);ctx.stroke();}for(let x=0;x<canvas.width;x+=gridSpacing){ctx.globalAlpha=0.3;ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,canvas.height);ctx.stroke();}ctx.globalAlpha=1.0;ctx.shadowBlur=0;}

        // --- 게임 초기화 ---
        function startGame() {
            highScore=localStorage.getItem('shooterHighScore')||0;
            highScoreElement.textContent=`High: ${highScore}`;
            player=new Player(canvas.width/2,canvas.height/2,15,playerColor,3.5);
            bullets=[];
            enemies=[];
            enemyBullets=[];
            particles=[];
            pickups=[];
            score=0;
            gameOver=false;
            isPaused=false;
            keys={};
            mousePos={x:canvas.width/2,y:canvas.height/2};
            enemySpawnTimer=0;
            
            // 난이도에 따른 적 스폰 간격 설정
            currentEnemySpawnInterval = baseEnemySpawnInterval / difficultyMultipliers[currentDifficulty].enemySpawn;
            
            difficultyMultiplier=1.0;
            currentUpgradeLevel=0;
            scoreElement.textContent=`Score: ${score}`;
            updateUpgradeUI();
            messageBox.style.display='none';
            newHighScoreMessageElement.style.display='none';
            upgradeChoiceOverlay.style.display='none';
            upgradeMessageElement.style.opacity=0;
            
            // 이벤트 리스너 설정
            setupEventListeners();
            
            // 게임 루프 시작
            if(gameLoopId) cancelAnimationFrame(gameLoopId);
            gameLoop();
        }
        
        function setupEventListeners() {
            window.removeEventListener('keydown',handleKeyDown);
            window.removeEventListener('keyup',handleKeyUp);
            canvas.removeEventListener('mousemove',updateMousePos);
            canvas.removeEventListener('mousedown',handleMouseDown);
            restartButton.removeEventListener('click',init);
            upgradeFirerateButton.removeEventListener('click',handleUpgradeChoice);
            upgradeDamageButton.removeEventListener('click',handleUpgradeChoice);
            upgradeSpreadButton.removeEventListener('click',handleUpgradeChoice);
            upgradeDashButton.removeEventListener('click',handleUpgradeChoice);
            
            window.addEventListener('keydown',handleKeyDown);
            window.addEventListener('keyup',handleKeyUp);
            canvas.addEventListener('mousemove',updateMousePos);
            canvas.addEventListener('mousedown',handleMouseDown);
            restartButton.addEventListener('click',init);
            upgradeFirerateButton.addEventListener('click',handleUpgradeChoice);
            upgradeDamageButton.addEventListener('click',handleUpgradeChoice);
            upgradeSpreadButton.addEventListener('click',handleUpgradeChoice);
            upgradeDashButton.addEventListener('click',handleUpgradeChoice);
        }
        
        function init() {
            // 난이도 선택 화면 표시
            difficultyOverlay.style.display = 'flex';
        }

        // --- 입력 처리 (이전과 동일) ---
        function handleKeyDown(event){const k=event.key.toLowerCase();keys[k]=true;if(k==='shift'&&!isPaused&&!gameOver){player.triggerDash();}}
        function handleKeyUp(event){keys[event.key.toLowerCase()]=false;}
        function handleMouseDown(event){if(!gameOver&&!isPaused){player.shoot();}}
        function handleUpgradeChoice(event){if(!player||player.upgradePoints<=0)return;if(player.spendUpgradePoint()){const c=event.target.id;if(c==='upgrade-firerate')player.upgradeFireRate();else if(c==='upgrade-damage')player.upgradeDamage();else if(c==='upgrade-spread')player.upgradeSpread();else if(c==='upgrade-dash')player.upgradeDashCooldown();updateUpgradeUI();upgradeChoiceOverlay.style.display='none';isPaused=false;}}

        // --- 게임 루프, 로직 업데이트, 그리기 함수 (이전과 동일) ---
        function gameLoop(){if(gameOver){finalScoreElement.textContent=`Job Score: ${score}`;if(score>highScore){highScore=score;localStorage.setItem('shooterHighScore',highScore);highScoreElement.textContent=`High: ${highScore}`;newHighScoreMessageElement.style.display='block';}else{newHighScoreMessageElement.style.display='none';}messageBox.style.display='flex';return;} gameLoopId=requestAnimationFrame(gameLoop); if(player.upgradePoints>0&&!isPaused){isPaused=true;updateUpgradeUI();upgradeChoiceOverlay.style.display='flex';} if(!isPaused){updateGameLogic();} drawGameElements();}
        function updateGameLogic(){
            const dm = difficultyMultipliers[currentDifficulty];
            difficultyMultiplier=1+(score/7000);
            
            player.update();
            
            bullets=bullets.filter(b=>b.x+b.radius>0&&b.x-b.radius<canvas.width&&b.y+b.radius>0&&b.y-b.radius<canvas.height);
            bullets.forEach(b=>b.update());
            
            enemyBullets=enemyBullets.filter(eb=>eb.x+eb.radius>0&&eb.x-eb.radius<canvas.width&&eb.y+eb.radius>0&&eb.y-eb.radius<canvas.height);
            enemyBullets.forEach(eb=>eb.update());
            
            particles=particles.filter(p=>p.alpha>0);
            particles.forEach(p=>p.update());
            
            pickups=pickups.filter(p=>p.life>0);
            pickups.forEach(p=>p.update());
            
            enemySpawnTimer++;
            
            // 난이도에 따른 적 스폰 간격 조정
            currentEnemySpawnInterval=Math.max(
                minEnemySpawnInterval,
                baseEnemySpawnInterval/(difficultyMultiplier*0.5+0.5) / dm.enemySpawn
            );
            
            if(enemySpawnTimer>=currentEnemySpawnInterval){
                spawnEnemy();
                enemySpawnTimer=0;
            } 
            
            pickups.forEach((p,i)=>{
                if(detectCollisionPlayerPickup(player,p)){
                    player.heal(p.healAmount);
                    pickups.splice(i,1);
                    showUpgradeMessage(`Nano-Medkit Acquired! +${p.healAmount}`);
                }
            }); 
            
            enemyBullets=enemyBullets.filter(eb=>{
                if(detectCollisionBulletPlayer(eb,player)){
                    // 무적 상태가 아닐 때만 데미지
                    if(!player.isInvincible) {
                        // 난이도에 따른 데미지 조정
                        player.takeDamage(10 * dm.enemyDamage);
                    }
                    // 총알은 항상 제거
                    createExplosion(eb.x,eb.y,eb.color,5,1.5);
                    return false;
                }
                return true;
            }); 
            
            if(gameOver) return; 
            
            const remainingEnemies=[];
            enemies.forEach(enemy=>{
                enemy.update();
                let enemyAlive=true;
                
                if(detectCollisionPlayerEnemy(player,enemy)){
                    // 무적 상태가 아닐 때만 데미지
                    if(!player.isInvincible) {
                        // 난이도에 따른 데미지 조정
                        player.takeDamage(Math.ceil((10+5*(difficultyMultiplier-1)) * dm.enemyDamage));
                    }
                    
                    // 충돌 효과는 항상 표시
                    createExplosion(enemy.x,enemy.y,enemy.color,15);
                    enemyAlive=false;
                    if(gameOver) return;
                } 
                
                if(enemyAlive){
                    bullets=bullets.filter(bullet=>{
                        if(detectCollisionCircleRect(bullet,enemy)){
                            if(enemy.takeDamage(player.bulletDamage)){
                                // 난이도에 따른 점수 조정
                                let sG=(enemy.type==='fast'?15:(enemy.type==='shooter'?20:10))*Math.ceil(difficultyMultiplier);
                                score+=Math.round(sG * dm.scoreMultiplier);
                                scoreElement.textContent=`Score: ${score}`;
                                createExplosion(enemy.x,enemy.y,enemy.color,15);
                                enemyAlive=false;
                                
                                if(Math.random()<0.05){
                                    pickups.push(new HealthPickup(enemy.x,enemy.y));
                                } 
                                
                                if(currentUpgradeLevel<scoreThresholds.length&&score>=scoreThresholds[currentUpgradeLevel]){
                                    player.addUpgradePoint();
                                    currentUpgradeLevel++;
                                    updateUpgradeUI();
                                }
                            } 
                            createExplosion(bullet.x,bullet.y,bulletColor,3,1.5);
                            return false;
                        } 
                        return true;
                    });
                } 
                
                if(enemyAlive){
                    remainingEnemies.push(enemy);
                }
            }); 
            
            enemies=remainingEnemies;
        }
        function drawGameElements(){ctx.save();let shakeX=0;let shakeY=0;if(screenShakeDuration>0){shakeX=(Math.random()-0.5)*screenShakeIntensity;shakeY=(Math.random()-0.5)*screenShakeIntensity;screenShakeDuration--;if(screenShakeDuration<=0)screenShakeIntensity=0;} ctx.translate(shakeX,shakeY); drawBackground();particles.forEach(p=>p.draw());pickups.forEach(p=>p.draw());enemies.forEach(e=>e.draw());bullets.forEach(b=>b.draw());enemyBullets.forEach(eb=>eb.draw());player.draw(); ctx.restore();}

        // --- 난이도 선택 버튼 이벤트 리스너 추가 ---
        easyButton.addEventListener('click', () => handleDifficultyChoice('easy'));
        normalButton.addEventListener('click', () => handleDifficultyChoice('normal'));
        hardButton.addEventListener('click', () => handleDifficultyChoice('hard'));
        
        // --- 게임 시작 ---
        init();

    </script>
</body>
</html>
